
Прочитав тестовое задание в голове сразу появились мысли, что хочу сделать еще, чего не было описано в ТЗ: выбор COM-порта пользователем; навигация, так как есть 2-я часть задания и помимо добавления кнопки, у других меняется функционал; менять не только яркость светодиода, но и частоту работы и в конце собрать  .exe файл для удобства использования.
## Qt
Так как никогда не использовал Qt сначала посмотрел базовые уроки (https://www.youtube.com/watch?v=g6fw5n9Gt-E&list=PL0lO_mIqDDFUaZe7H9kY6vWbSVrtwFv4M&index=1) и начал читать книгу по Qt6 "Разработка оконных приложений на C++" (пользовался им как справочником, но практически ничего не использовал, потому что виджеты рассматриваются только через код, без использования формы .ui).
### 1-я часть тестового задания.
Так как нет опыта написания на Qt и CubeIDE, сначала решил сделать тестовое задание на Arduino вместо STM32. Написал простой скетч в ArduinoIDE для вкл/выкл светодиода в зависимости от того, что передается через COM-port.
```cpp
#define LED_PIN 13
void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
}
void loop() {

  if (Serial.available() > 0) {
    char receivedChar = Serial.read();
    if (receivedChar == '1') {
      digitalWrite(LED_PIN, HIGH);
      Serial.println("LED ON");
      
    }

    else if (receivedChar == '0') {
      digitalWrite(LED_PIN, LOW);
      Serial.println("LED OFF");

    }
  }  
}
```

Пока не знаю как лучше передавать состояние, поэтому просто буду отправлять "1" или "0" чтобы включить/выключить светодиод. Дальше поищу как это лучше сделать и переделаю, когда начну писать в CubeIDE.
Во время поиска информации о том как передавать информацию через COM-порт в Qt использовал документацию QSerialPort и QSerialPortInfo (https://doc.qt.io/qt-6/qserialport.html#writeData и https://doc.qt.io/qt-6/qserialportinfo.html#availablePorts) и видео https://www.youtube.com/watch?v=9mVFnCA2qRg , в котором узнал про textEdit, подумал, что будет хорошо не только выводить информацию о COM-портах, но и после отправки данных на МК, отправлять их в ответ эхом для дебага. 
Параллельно учился работать с git bash. Создал git репозиторий на github и коммитил свой прогресс для проекта на Qt.
С первой частью Qt+Arduino проблем не возникло, вся информация находилась быстро, хоть с первого раза ничего не работало, но на решение каких-либо проблем много времени не уходило благодаря базовым урокам + поиску информации по каким-либо функциям компонентов в интернете.
Единственная проблема была только в подключении библиотек QSerialPort и QSerialPortInfo, потому что при создании проекта по умолчанию был выбран CMake для системы сборки, а всю информацию которую я находил, была с проектами с qmake.
### 2-я часть
После написания первой части со стороны ПК, начал изучать создание доп. окон и навигацию по ним.
Начальная задумка была такая.

![[Pasted image 20250618160834.png]]
Быстро стало понятно, что главный экран в этом случае будет бесполезен и за "главный экран" выбрал 1-ю часть задания.
Столкнулся с проблемой, нашел видео с навигацией в Qt, в котором не объясняется как из нового окна вернуться к предыдущему + открывается новое диалоговое окно, а не обновляется существующее. Поэтому решил, что будет лучше это сделать в одном окне при помощи QStackedWidget, о котором я узнал в процессе чтения информации по навигации в Qt.
Создал по кнопке на каждой странице, чтобы при нажатии менять её индекс и тем самым осуществлять навигацию.
Искал как лучше задавать уровень ШИМа, текстовое поле, которое лежало на поверхности имело много недостатков. Надо проверять на тип введенных данных, попадает ли в диапазон заданное значение, да и со стороны пользователя выглядит неудобным что-то вводить. Поэтому в процессе изучения Qt нашел слайдеры и решил, что это именно то, что мне нужно. Не придется выполнять проверки, потому что мы сразу ограничим пользователя ползунком. Единственное, что со стороны пользователя может быть не понятным диапазон (от 0 до 255 или тем более до 65535), поэтому я задал диапазон слайдеру от 0 до 100% яркости и через написанную функцию `long mapValue()`(в ArduinoIDE есть встроенная функция `map()` для изменения диапазона значений, но в C++ её нет, поэтому я просто переписал её сам) изменял диапазон 0-100 в 0-255 (для ардуино). 
После этого пытался просто передать значение ШИМа через COM-порт, но функция write() не принимает на вход int, только QByteArray, нашел как это сделать (сначала преобразовать в QString, а только потом QByteArray `QString dataPwm = QString::number(pwm); dataPwm.toUtf8()`.
Чтобы видеть, что получает ардуино, нужна функция чтения данных. Во время поиска нашел вот такой пример:
```cpp
void MainWindow::receive_Data()
{
    if (serial->isOpen()){
        QByteArray data = serial->readAll();
        QString receivedData = QString::fromUtf8(data);
        ui->textEdit->append(receivedData);
    }
}
```

>[!note]- Функция не срабатывала, узнал про слоты и сигналы. Добавил connect (serial, &QSerialPort::readyRead, this, &MainWindow::receive_Data) и все заработало 

Но у нас нет проверки на конец пакета, так что данные могут потеряться. Поэтому я её чуть дополнил, добавив две проверки:
```cpp
void MainWindow::receive_Data()
{
    // Вариант 2 (лучше)
    if (serial->isOpen()){
        while (serial->bytesAvailable()){
            dataFromSerial += serial->readAll();
            if (dataFromSerial.at(dataFromSerial.length() - 1) == char(13) ||
                dataFromSerial.at(dataFromSerial.length() - 1) == char(10))
            {
                IsDataReceived = true;
            }
            if (IsDataReceived == true){
                ui->textEdit->append(dataFromSerial);
                dataFromSerial = "";
                IsDataReceived = false;
            }
        }
    }
}
```
После чего я начал искать информацию о том как лучше будет формировать пакет данных. Остановился на передаче строки с сепараторами.
Необходимо ведь не только передать информацию о том, вклю/выкл. светодиод и уровень яркости(для 2-й части), но и с какой страницы это было отправлено. Поэтому пакет выглядит так: [0] - часть задания(выбор светодиода) ";" [1] - вкл/выкл";" [2] - ШИМ + "\n\r" чтобы со стороны МК закончить чтение и формирование пакета данных.
Так как я не могу управлять яркостью светодиода на самой плате, взял обычный светодиод и резистор + макетную плату, чтобы отправляя данные со второй страницы, управлять другим светодиодом.
**Финальный скетч для Arduino выглядит так:**
```cpp
#define LED_PIN 13
#define LED_PIN_OUT 9

String data;

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(LED_PIN_OUT, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  analogWrite(LED_PIN_OUT, 0);
}
  
void loop() {

  if (Serial.available() > 0) {
    String receivedData = Serial.readStringUntil("\n");
    receivedData.trim(); // Удаляет лишние пробелы и символы перевода строки
    int params[10];
    int paramCount = 0;
    int lastIndex = 0;
    for (int i = 0; i < receivedData.length(); i++){
      if (receivedData.charAt(i) == ';'){
        String paramStr = receivedData.substring(lastIndex, i);
        params[paramCount++] = paramStr.toInt();
        lastIndex = i + 1;
      }
    }

    if (lastIndex < receivedData.length()){
      String paramStr = receivedData.substring(lastIndex);
      params[paramCount++] = paramStr.toInt();
    }

    // Обработка параметров
    if (paramCount >= 1) {
      int page = params[0];  // Первый параметр — номер страницы
      Serial.print("Page: ");
      Serial.println(page);
      if (paramCount >= 2) {
        int ledState = params[1];  // Второй параметр — состояние светодиода
        if (page == 0 && ledState == 1){
          digitalWrite(LED_PIN, ledState);
        }
        else if (page == 0 && ledState == 0){
          digitalWrite(LED_PIN, ledState);
        }
        Serial.print("LED: ");
        Serial.println(ledState);
      }

      if (paramCount >= 3) {
        int ledState = params[1];
        int pwm = params[2];
        int endMarker = params[3];  // Третий параметр — маркер конца
        if (page == 1 && ledState == 1 && pwm >= 0 && pwm <= 255){
          analogWrite(LED_PIN_OUT, pwm);
          Serial.print("PWM: ");
          Serial.println(pwm);
        }
        else{
          analogWrite(LED_PIN_OUT, 0);
          Serial.println("End of message");
        }
        if (endMarker == -1) {
          Serial.println("End of message");
        }
      }
    }
  }
}
```
>[!info]- Для ардуино на тот момент не знал каким символов лучше закрыть пакет данных, поэтому вместо "\n\r" отправлял "-1".

После этого я перешел уже на STM32 (о нём в другом файле в проекте по STM).
Понял, что неудобная навигация между страницами, так как подключение к COM-портам и textEdit как обратная связь находятся на 1-й странице и делать постоянно эти переключения неудобно + дублирование кнопок(хоть у них и разный функционал в зависимости от части ТЗ). Поэтому переместил всё на одну страницу и добавил radioButton для выбора каким светодиодом будем управлять(та часть, которая относится только к 2-й части задания скрыта, пока radioButton неактивна).
Добавил кнопки обновления информации о подключенных COM-портах, так как пользователь сначала может открыть программу, а только потом подключить COM-порт.
В конце добавил слайдер для частоты мигания выводным светодиодом, скомпоновал виджеты и покрасил кнопки.
Собрал exe и закоммитил на github "финальную" версию.
### Не получилось сделать
Не получилось добавить информацию в статус бар более чем 1 элемент (не только COM порт, но и скорость и тд.)
Не получилось отработать ошибку при отключении COM-порта.
Не выводить в textEdit ответ от МК "\n\r" (между ответами большое расстояние).
Не получилось изменить цвет кнопки при наведении на неё (ни кодом, ни через .ui styleSheet). Не сработало...
```cpp
QPushButton:hover {  
background-color: lightblue;  
color: white;  
}
```
